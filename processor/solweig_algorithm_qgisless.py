# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ProcessingUMEP
                                 A QGIS plugin
 UMEP for processing toolbox
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-02
        copyright            : (C) 2020 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Fredrik Lindberg'
__date__ = '2020-04-02'
__copyright__ = '(C) 2020 by Fredrik Lindberg'

from logging import exception

import numpy as np
from osgeo import gdal, osr
# import rasterio
import os
# from qgis.PyQt.QtGui import QIcon
import inspect
from pathlib import Path
from util.misc import saveraster
import zipfile
from functions.SOLWEIGpython.UTIL.Solweig_v2015_metdata_noload import Solweig_2015a_metdata_noload
from functions.SOLWEIGpython.UTIL.clearnessindex_2013b import clearnessindex_2013b
from functions.SOLWEIGpython.Tgmaps_v1 import Tgmaps_v1
from functions.SOLWEIGpython import Solweig_2022a_calc_forprocessing as so
from functions.SOLWEIGpython import WriteMetadataSOLWEIG
from functions.SOLWEIGpython import PET_calculations as p
from functions.SOLWEIGpython import UTCI_calculations as utci
from functions.SOLWEIGpython.CirclePlotBar import PolarBarPlot
import matplotlib.pyplot as plt
from shutil import rmtree
import string
import random
from shutil import copyfile




class SOLWEIGAlgorithm():
    """
    A class to process the SOLWEIG algorithm inputs.

    Parameters:
    - INPUT_DSM:        Digital Surface Model (DSM) input file.
    - INPUT_SVF:        ZIP Sky View Factor (SVF) input files.
    - INPUT_CDSM:       Canopy DSM input file.
    - INPUT_TDSM:       Trunk zone DSM input file.
    - INPUT_HEIGHT:
    - INPUT_ASPECT:     Wall aspect input file.
    - TRANS_VEG:        Vegetation transmissivity value or input file.
    - LEAF_START:       Start of the leaf-on period (date or DOY).
    - LEAF_END:         End of the leaf-on period (date or DOY).
    - CONIFER_TREES:    Boolean: if true trees are seen af coniferous
    - INPUT_THEIGHT:    Trunk height (percentage, if no trunk zone DSM)
    - INPUT_LC:         Land cover classification input file.
    - USE_LC_BUILD:     Boolean indicating whether to use land cover for building footprints.
    - INPUT_DEM:        Digital Elevation Model (DEM) input file.
    - SAVE_BUILD:       Boolean indicating whether to save the processed building footprint.
    - INPUT_ANISO:      Anisotropic input data or parameter.
    - ALBEDO_WALLS:     ETC.
    """

    def __init__(self, INPUT_DSM, INPUT_SVF, INPUT_CDSM,  INPUT_HEIGHT, INPUT_ASPECT,
                 UTC, OUTPUT_DIR, INPUT_MET, INPUT_LC=None,  INPUT_DEM=None, INPUT_ANISO=None,
                 CONIFER_TREES=False, INPUT_THEIGHT=25, INPUT_TDSM=None, TRANS_VEG=3, LEAF_START=97, LEAF_END=300,
                 USE_LC_BUILD=True, SAVE_BUILD=False, ALBEDO_WALLS=0.2, ALBEDO_GROUND=0.15,
                 EMIS_WALLS=0.9, EMIS_GROUND=0.95, ABS_S=0.7, ABS_L=0.95, POSTURE=0,  ONLYGLOBAL=True,
                 OUTPUT_TMRT=True, OUTPUT_LUP=True, OUTPUT_KUP=True, OUTPUT_KDOWN=True, OUTPUT_LDOWN=True, OUTPUT_SH=True, OUTPUT_TREEPLANTER=False,
                 CYL=True):
        # Initialize the class with all the provided inputs
        self.INPUT_DSM = INPUT_DSM
        self.INPUT_SVF = INPUT_SVF
        self.INPUT_CDSM = INPUT_CDSM
        self.INPUT_TDSM = INPUT_TDSM
        self.INPUT_HEIGHT = INPUT_HEIGHT
        self.INPUT_ASPECT = INPUT_ASPECT
        self.TRANS_VEG = TRANS_VEG
        self.LEAF_START = LEAF_START
        self.LEAF_END = LEAF_END
        self.CONIFER_TREES = CONIFER_TREES
        self.INPUT_THEIGHT = INPUT_THEIGHT
        self.INPUT_LC = INPUT_LC
        self.USE_LC_BUILD = USE_LC_BUILD
        self.INPUT_DEM = INPUT_DEM
        self.SAVE_BUILD = SAVE_BUILD
        self.INPUT_ANISO = INPUT_ANISO

        # Enivornmental parameters
        self.ALBEDO_WALLS = ALBEDO_WALLS
        self.ALBEDO_GROUND = ALBEDO_GROUND
        self.EMIS_WALLS = EMIS_WALLS
        self.EMIS_GROUND = EMIS_GROUND

        # Tmrt parameters
        self.ABS_S = ABS_S
        self.ABS_L = ABS_L
        self.POSTURE = POSTURE

        # Meteorology
        self.INPUT_MET = INPUT_MET
        self.ONLYGLOBAL = ONLYGLOBAL
        self.UTC = UTC

        # Output
        self.OUTPUT_DIR = OUTPUT_DIR
        self.OUTPUT_TMRT = OUTPUT_TMRT
        self.OUTPUT_LUP = OUTPUT_LUP
        self.OUTPUT_KUP = OUTPUT_KUP
        self.OUTPUT_KDOWN = OUTPUT_KDOWN
        self.OUTPUT_LDOWN = OUTPUT_LDOWN
        self.OUTPUT_SH = OUTPUT_SH
        self.OUTPUT_TREEPLANTER = OUTPUT_TREEPLANTER

        self.CYL = CYL

    #PET parameters
    # AGE = 'AGE'
    # ACTIVITY = 'ACTIVITY'
    # CLO = 'CLO'
    # WEIGHT = 'WEIGHT'
    # HEIGHT = 'HEIGHT'
    # SEX = 'SEX'
    # SENSOR_HEIGHT = 'SENSOR_HEIGHT'
    #
    # #Optional settings
    # # POI = 'POI'
    # POI_FILE = 'POI_FILE'
    # POI_FIELD = 'POI_FIELD'
    # CYL = 'CYL'



   # def initAlgorithm(self, config):
        #ADVANCED PARAMETERS
        #POIs for thermal comfort estimations
        # poi = QgsProcessingParameterBoolean(self.POI,
        #     self.tr("Include Point of Interest(s) for thermal comfort calculations (PET and UTCI)"), defaultValue=False)
        # poi.setFlags(poi.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(poi)
        # poifile = QgsProcessingParameterFeatureSource(self.POI_FILE,
        #     self.tr('Vector point file including Point of Interest(s) for thermal comfort calculations (PET and UTCI)'), [QgsProcessing.TypeVectorPoint], optional=True)
        # poifile.setFlags(poifile.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(poifile)
        # poi_field = QgsProcessingParameterField(self.POI_FIELD,
        #     self.tr('ID field'),'', self.POI_FILE, QgsProcessingParameterField.Numeric, optional=True)
        # poi_field.setFlags(poi_field.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(poi_field)
        #
        # #PET parameters
        # age = QgsProcessingParameterNumber(self.AGE, self.tr('Age (yy)'),
        #         QgsProcessingParameterNumber.Integer,
        #         QVariant(35), optional=True, minValue=0, maxValue=120)
        # age.setFlags(age.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(age)
        # act = QgsProcessingParameterNumber(self.ACTIVITY, self.tr('Activity (W)'),
        #         QgsProcessingParameterNumber.Double,
        #         QVariant(80), optional=True, minValue=0, maxValue=1000)
        # act.setFlags(act.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(act)
        # clo = QgsProcessingParameterNumber(self.CLO, self.tr('Clothing (clo)'),
        #         QgsProcessingParameterNumber.Double,
        #         QVariant(0.9), optional=True, minValue=0, maxValue=10)
        # clo.setFlags(clo.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(clo)
        # wei = QgsProcessingParameterNumber(self.WEIGHT, self.tr('Weight (kg)'),
        #         QgsProcessingParameterNumber.Integer,
        #         QVariant(75), optional=True, minValue=0, maxValue=500)
        # wei.setFlags(wei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(wei)
        # hei = QgsProcessingParameterNumber(self.HEIGHT, self.tr('Height (cm)'),
        #         QgsProcessingParameterNumber.Integer,
        #         QVariant(180), optional=True, minValue=0, maxValue=250)
        # hei.setFlags(hei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(hei)
        # sex = QgsProcessingParameterEnum(
        #     self.SEX, self.tr('Sex'), ['Male', 'Female'], optional=True, defaultValue=0)
        # sex.setFlags(sex.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(sex)
        # shei = QgsProcessingParameterNumber(self.SENSOR_HEIGHT, self.tr('Height of wind sensor (m agl)'),
        #         QgsProcessingParameterNumber.Double,
        #         QVariant(10), optional=True, minValue=0, maxValue=250)
        # shei.setFlags(shei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(shei)
        #
        # #OUTPUT
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_TMRT,
        #     self.tr("Save Mean Radiant Temperature raster(s)"), defaultValue=True))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_KDOWN,
        #     self.tr("Save Incoming shortwave radiation raster(s)"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_KUP,
        #     self.tr("Save Outgoing shortwave radiation raster(s)"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_LDOWN,
        #     self.tr("Save Incoming longwave radiation raster(s)"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_LUP,
        #     self.tr("Save Outgoing longwave radiation raster(s)"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_SH,
        #     self.tr("Save shadow raster(s)"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterBoolean(self.OUTPUT_TREEPLANTER,
        #     self.tr("Save necessary raster(s) for the TreePlanter and Spatial TC tools"), defaultValue=False))
        # self.addParameter(QgsProcessingParameterFolderDestination(self.OUTPUT_DIR,
        #                                              'Output folder'))
        #
        # self.plugin_dir = os.path.dirname(__file__)

        # TO DO: THIS IS NOW AN ABSOLUTE PATH
        temp_dir_name = 'temp-' + ''.join(random.choice(string.ascii_uppercase) for _ in range(8))
        self.temp_dir = os.path.join("D:/Geomatics/", temp_dir_name)

    def processAlgorithm(self):
        np.seterr(divide='ignore', invalid='ignore')
 
        # InputParameters
        filepath_dsm = self.INPUT_DSM
        transVeg = float(self.TRANS_VEG / 100.)
        firstdayleaf = int(self.LEAF_START)
        lastdayleaf = int(self.LEAF_START)
        conifer_bool = bool(self.CONIFER_TREES)
        vegdsm_path = self.INPUT_CDSM
        vegdsm2_path = self.INPUT_TDSM
        lcgrid_path =  self.INPUT_LC
        useLcBuild = bool(self.USE_LC_BUILD)
        dem = None
        inputSVF = self.INPUT_SVF
        whlayer_path = self.INPUT_HEIGHT
        walayer_path = self.INPUT_ASPECT
        trunkr = float(self.INPUT_THEIGHT)
        onlyglobal = bool( self.ONLYGLOBAL)
        utc = float(self.UTC)
        inputMet = self.INPUT_MET
        # usePOI = self.parameterAsBool(parameters, self.POI, context)
        # poilyr = self.POI_FILE
        # poi_field = None
        # mbody = None
        # ht = None
        # clo = None
        # age = None
        # activity = None
        # sex = None
        # sensorheight = None
        saveBuild = bool(self.SAVE_BUILD)
        demforbuild = 0
        folderPathPerez = self.INPUT_ANISO
        # poisxy = None
        # poiname = None

        # Other parameters #
        absK = float(self.ABS_S)
        absL = float(self.ABS_L)
        pos = int(self.POSTURE)
        
        if bool(self.CYL):
            cyl = 1
        else:
            cyl = 0

        if pos == 0:
            Fside = 0.22
            Fup = 0.06
            height = 1.1
            Fcyl = 0.28
        else:
            Fside = 0.166666
            Fup = 0.166666
            height = 0.75
            Fcyl = 0.2

        albedo_b = float(self.ALBEDO_WALLS)
        albedo_g = float(self.ALBEDO_GROUND)
        ewall = float(self.EMIS_WALLS)
        eground = float(self.EMIS_GROUND)
        elvis = 0 # option removed 20200907 in processing UMEP

        outputDir = self.OUTPUT_DIR
        outputTmrt = bool(self.OUTPUT_TMRT)
        outputSh = bool(self.OUTPUT_SH)
        outputKup = bool(self.OUTPUT_KUP)
        outputKdown = bool(self.OUTPUT_KDOWN)
        outputLup = bool(self.OUTPUT_LUP)
        outputLdown = bool(self.OUTPUT_LDOWN)
        outputTreeplanter =  bool(self.OUTPUT_TREEPLANTER)
        outputKdiff = False
        #outputSstr = False

        # If "Save necessary rasters for TreePlanter tool" is ticked, save the following raster for TreePlanter or Spatial TC
        if outputTreeplanter:
            outputTmrt = True
            outputKup = True
            outputKdown = True
            outputLup = True
            outputLdown = True
            outputSh = True
            saveBuild = True
            outputKdiff = True
            #outputSstr = True

        if not (os.path.isdir(outputDir)):
            os.mkdir(outputDir)

        gdal_dsm = gdal.Open(filepath_dsm)
        dsm = gdal_dsm.ReadAsArray().astype(float)
        sizex = dsm.shape[0]
        sizey = dsm.shape[1]
        rows = dsm.shape[0]
        cols = dsm.shape[1]

        # response to issue #85
        nd = gdal_dsm.GetRasterBand(1).GetNoDataValue()
        dsm[dsm == nd] = 0.
        # dsmcopy = np.copy(dsm)
        if dsm.min() < 0:
            dsmraise = np.abs(dsm.min())
            dsm = dsm + dsmraise
            print('Digital Surface Model (DSM) included negative values. DSM raised with ' + str(dsmraise) + 'm.')
        else:
            dsmraise = 0

        # Get latlon from grid coordinate system
        old_cs = osr.SpatialReference()
        dsm_ref = gdal_dsm.GetProjection()
        old_cs.ImportFromWkt(dsm_ref)

        # TO DO: IF CODE WORKS, CHANGE TO
        # new_cs = osr.SpatialReference()
        # new_cs.ImportFromEPSG(4326)
        wgs84_wkt = """
        GEOGCS["WGS 84",
            DATUM["WGS_1984",
                SPHEROID["WGS 84",6378137,298.257223563,
                    AUTHORITY["EPSG","7030"]],
                AUTHORITY["EPSG","6326"]],
            PRIMEM["Greenwich",0,
                AUTHORITY["EPSG","8901"]],
            UNIT["degree",0.01745329251994328,
                AUTHORITY["EPSG","9122"]],
            AUTHORITY["EPSG","4326"]]"""

        new_cs = osr.SpatialReference()
        new_cs.ImportFromWkt(wgs84_wkt)

        transform = osr.CoordinateTransformation(old_cs, new_cs)
        widthx = gdal_dsm.RasterXSize
        heightx = gdal_dsm.RasterYSize
        geotransform = gdal_dsm.GetGeoTransform()
        minx = geotransform[0]
        miny = geotransform[3] + widthx * geotransform[4] + heightx * geotransform[5]
        lonlat = transform.TransformPoint(minx, miny)
        gdalver = float(gdal.__version__[0])
        if gdalver == 3.:
            lon = lonlat[1] #changed to gdal 3
            lat = lonlat[0] #changed to gdal 3
        else:
            lon = lonlat[0] #changed to gdal 2
            lat = lonlat[1] #changed to gdal 2
        scale = 1 / geotransform[1]

        alt = np.median(dsm)
        if alt < 0:
            alt = 3
        print('Longitude derived from DSM: ' + str(lon))
        print('Latitude derived from DSM: ' + str(lat))

        trunkfile = 0
        trunkratio = 0
        # psi = transVeg / 100.0

        # if useVegdem:
        if vegdsm_path is not None:
            usevegdem = 1
            print('Vegetation scheme activated')

            gdal_vegdsm = gdal.Open(vegdsm_path)
            vegdsm = gdal_vegdsm.ReadAsArray().astype(float)

            vegsizex = vegdsm.shape[0]
            vegsizey = vegdsm.shape[1]

            if not (vegsizex == sizex) & (vegsizey == sizey):
                raise Exception("Error in Vegetation Canopy DSM: All rasters must be of same extent and resolution")

            if vegdsm2_path is not None:
                gdal_vegdsm2 = gdal.Open(vegdsm2_path)
                vegdsm = gdal_vegdsm.ReadAsArray().astype(float)
            else:
                trunkratio = trunkr / 100.0
                vegdsm2 = vegdsm * trunkratio
                vegdsm2_path = None

            vegsizex = vegdsm2.shape[0]
            vegsizey = vegdsm2.shape[1]

            if not (vegsizex == sizex) & (vegsizey == sizey):  # &
                raise Exception("Error in Trunk Zone DSM: All rasters must be of same extent and resolution")
        else:
            vegdsm = np.zeros([rows, cols])
            vegdsm2 = np.zeros([rows, cols])
            usevegdem = 0
            vegdsm_path = None
            vegdsm2_path = None

        # Land cover
        if lcgrid_path is not None:
            landcover = 1
            print('Land cover scheme activated')

            # load raster
            gdal_lcgrid = gdal.Open(lcgrid_path)
            lcgrid = gdal_lcgrid.ReadAsArray().astype(float)

            lcsizex = lcgrid.shape[0]
            lcsizey = lcgrid.shape[1]

            if not (lcsizex == sizex) & (lcsizey == sizey):
                raise Exception("Error in land cover grid: All grids must be of same extent and resolution")

            baddataConifer = (lcgrid == 3)
            baddataDecid = (lcgrid == 4)
            if baddataConifer.any():
                raise Exception("Error in land cover grid: Land cover grid includes Confier land cover class. Ground cover information (underneath canopy) is required.")
            if baddataDecid.any():
                raise Exception("Error in land cover grid: Land cover grid includes Decidiuous land cover class. Ground cover information (underneath canopy) is required.")
            if np.isnan(lcgrid).any():
                raise Exception("Error in land cover grid: Land cover grid includes NaN values. Use the QGIS Fill NoData cells tool to remove NaN values.")
        else:
            lcgrid_path = None
            landcover = 0

        # DEM #
        if not useLcBuild:
            demforbuild = 1
            dem = self.INPUT_DEM

            if dem is None:
                raise Exception("Error: No valid DEM selected")

            # load raster
            gdal.AllRegister()
            provider = dem.dataProvider()
            filePathOld = str(provider.dataSourceUri())
            dataSet = gdal.Open(filePathOld)
            dem = dataSet.ReadAsArray().astype(float)

            demsizex = dem.shape[0]
            demsizey = dem.shape[1]

            if not (demsizex == sizex) & (demsizey == sizey):
                raise Exception( "Error in DEM: All grids must be of same extent and resolution")

            # response to issue and #230
            nd = dataSet.GetRasterBand(1).GetNoDataValue()
            dem[dem == nd] = 0.
            if dem.min() < 0:
                demraise = np.abs(dem.min())
                dem = dem + demraise
                print('Digital Evevation Model (DEM) included negative values. DEM raised with ' + str(demraise) + 'm.')
            else:
                demraise = 0

            alt = np.median(dem)
            if alt > 0:
                alt = 3.

            if (dsmraise != demraise) and (dsmraise - demraise > 0.5):
                print('WARNiNG! DEM and DSM was raised unequally (difference > 0.5 m). Check your input data!')

        #SVFs
        zip = zipfile.ZipFile(inputSVF, 'r')
        zip.extractall(self.temp_dir)
        zip.close()

        try:
            dataSet = gdal.Open(self.temp_dir + "/svf.tif")
            svf = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfN.tif")
            svfN = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfS.tif")
            svfS = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfE.tif")
            svfE = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfW.tif")
            svfW = dataSet.ReadAsArray().astype(float)

            if usevegdem == 1:
                dataSet = gdal.Open(self.temp_dir + "/svfveg.tif")
                svfveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfNveg.tif")
                svfNveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfSveg.tif")
                svfSveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfEveg.tif")
                svfEveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfWveg.tif")
                svfWveg = dataSet.ReadAsArray().astype(float)

                dataSet = gdal.Open(self.temp_dir + "/svfaveg.tif")
                svfaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfNaveg.tif")
                svfNaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfSaveg.tif")
                svfSaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfEaveg.tif")
                svfEaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfWaveg.tif")
                svfWaveg = dataSet.ReadAsArray().astype(float)
            else:
                svfveg = np.ones((rows, cols))
                svfNveg = np.ones((rows, cols))
                svfSveg = np.ones((rows, cols))
                svfEveg = np.ones((rows, cols))
                svfWveg = np.ones((rows, cols))
                svfaveg = np.ones((rows, cols))
                svfNaveg = np.ones((rows, cols))
                svfSaveg = np.ones((rows, cols))
                svfEaveg = np.ones((rows, cols))
                svfWaveg = np.ones((rows, cols))
        except:
            raise Exception("SVF import error: The zipfile including the SVFs seems corrupt. Retry calcualting the SVFs in the Pre-processor or choose another file.")

        svfsizex = svf.shape[0]
        svfsizey = svf.shape[1]

        if not (svfsizex == sizex) & (svfsizey == sizey):  # &
            raise Exception("Error in svf rasters: All grids must be of same extent and resolution")

        tmp = svf + svfveg - 1.
        tmp[tmp < 0.] = 0.
        # %matlab crazyness around 0
        svfalfa = np.arcsin(np.exp((np.log((1. - tmp)) / 2.)))

        print('Sky View Factor rasters loaded')

        # wall height layer
        if whlayer_path is None:
            raise Exception("Error: No valid wall height raster layer is selected")
        gdal_wallheight = gdal.Open(whlayer_path)
        wallheight = gdal_wallheight.ReadAsArray().astype(float)

        vhsizex = wallheight.shape[0]
        vhsizey = wallheight.shape[1]
        if not (vhsizex == sizex) & (vhsizey == sizey):
            raise Exception("Error in Wall height raster: All rasters must be of same extent and resolution")

        # wall aspectlayer
        if walayer_path is None:
            raise Exception("Error: No valid wall aspect raster layer is selected")
        gdal_wallaspect = gdal.Open(walayer_path)
        wallaspect = gdal_wallaspect.ReadAsArray().astype(float)

        vasizex = wallaspect.shape[0]
        vasizey = wallaspect.shape[1]
        if not (vasizex == sizex) & (vasizey == sizey):
            raise Exception("Error in Wall aspect raster: All rasters must be of same extent and resolution")

        voxelheight = geotransform[1]  # float

        # Metdata
        headernum = 1
        delim = ' '
        Twater = []

        try:
            self.metdata = np.loadtxt(inputMet,skiprows=headernum, delimiter=delim)
            metfileexist = 1
        except:
            raise Exception("Error: Make sure format of meteorological file is correct. You can"
                                                        "prepare your data by using 'Prepare Existing Data' in "
                                                        "the Pre-processor")

        testwhere = np.where((self.metdata[:, 14] < 0.0) | (self.metdata[:, 14] > 1300.0))
        if testwhere[0].__len__() > 0:
             raise Exception("Error: Kdown - beyond what is expected at line: " + str(testwhere[0] + 1))

        if self.metdata.shape[1] == 24:
            print("Meteorological data successfully loaded")
        else:
            raise Exception("Error: Wrong number of columns in meteorological data.")

        print("Calculating sun positions for each time step")
        location = {'longitude': lon, 'latitude': lat, 'altitude': alt}
        YYYY, altitude, azimuth, zen, jday, leafon, dectime, altmax = \
            Solweig_2015a_metdata_noload(self.metdata,location, utc)

        # Creating vectors from meteorological input
        DOY = self.metdata[:, 1]
        hours = self.metdata[:, 2]
        minu = self.metdata[:, 3]
        Ta = self.metdata[:, 11]
        RH = self.metdata[:, 10]
        radG = self.metdata[:, 14]
        radD = self.metdata[:, 21]
        radI = self.metdata[:, 22]
        P = self.metdata[:, 12]
        Ws = self.metdata[:, 9]
        
        # Check if diffuse and direct radiation exist
        if onlyglobal == 0:
            if np.min(radD) == -999:
                raise Exception("Diffuse radiation include NoData values",
                                        'Tick in the box "Estimate diffuse and direct shortwave..." or aqcuire '
                                        'observed values from external data sources.')
            if np.min(radI) == -999:
                raise Exception("Direct radiation include NoData values",
                                        'Tick in the box "Estimate diffuse and direct shortwave..." or aqcuire '
                                        'observed values from external data sources.')

        # POIs check
        # if poilyr is not None: # usePOI:
        #     #header = 'yyyy id   it imin dectime altitude azimuth kdir kdiff kglobal kdown   kup    keast ksouth ' \
        #     #            'kwest knorth ldown   lup    least lsouth lwest  lnorth   Ta      Tg     RH    Esky   Tmrt    ' \
        #     #            'I0     CI   Shadow  SVF_b  SVF_bv KsideI PET UTCI'
        #
        #     header = 'yyyy id   it imin dectime altitude azimuth kdir kdiff kglobal kdown   kup    keast ksouth ' \
        #                 'kwest knorth ldown   lup    least lsouth lwest  lnorth   Ta      Tg     RH    Esky   Tmrt    ' \
        #                 'I0     CI   Shadow  SVF_b  SVF_bv KsideI PET UTCI  CI_Tg   CI_TgG  KsideD  Lside   diffDown    Kside'
        #
        #     poi_field = self.parameterAsFields(parameters, self.POI_FIELD, context)
        #     vlayer = poilyr
        #     prov = vlayer.dataProvider()
        #     fields = prov.fields()
        #     idx = vlayer.fields().indexFromName(poi_field[0])
        #     numfeat = vlayer.featureCount()
        #     poiname = []
        #     poisxy = np.zeros((numfeat, 3)) - 999
        #     ind = 0
        #     for f in vlayer.getFeatures():  # looping through each POI
        #         y = f.geometry().centroid().asPoint().y()
        #         x = f.geometry().centroid().asPoint().x()
        #
        #         poiname.append(f.attributes()[idx])
        #         poisxy[ind, 0] = ind
        #         poisxy[ind, 1] = np.ceil((x - minx) * scale) - 1
        #         if miny >= 0:
        #             poisxy[ind, 2] = np.ceil((miny + rows * (1. / scale) - y) * scale) - 1
        #         else:
        #             poisxy[ind, 2] = np.ceil((miny + rows * (1. / scale) - y) * scale) - 1
        #
        #         ind += 1
        #
        #     for k in range(0, poisxy.shape[0]):
        #         poi_save = []  # np.zeros((1, 33))
        #         data_out = outputDir + '/POI_' + str(poiname[k]) + '.txt'
        #         np.savetxt(data_out, poi_save,  delimiter=' ', header=header, comments='')
        #
        #     # Other PET variables
        #     mbody = self.parameterAsDouble(parameters, self.WEIGHT, context)
        #     ht = self.parameterAsDouble(parameters, self.HEIGHT, context) / 100.
        #     clo = self.parameterAsDouble(parameters, self.CLO, context)
        #     age = self.parameterAsDouble(parameters, self.AGE, context)
        #     activity = self.parameterAsDouble(parameters, self.WEIGHT, context)
        #     sex = self.parameterAsInt(parameters, self.SEX, context) + 1
        #     sensorheight = self.parameterAsDouble(parameters, self.SENSOR_HEIGHT, context)
        #
        #     feedback.setProgressText("Point of interest (POI) vector data successfully loaded")

        # %Parameterisarion for Lup
        if not height:
            height = 1.1

        # %Radiative surface influence, Rule of thumb by Schmid et al. (1990).
        first = np.round(height)
        if first == 0.:
            first = 1.
        second = np.round((height * 20.))

        if usevegdem == 1:
            # Conifer or deciduous
            if conifer_bool:
                leafon = np.ones((1, DOY.shape[0]))
            else:
                leafon = np.zeros((1, DOY.shape[0]))
                if firstdayleaf > lastdayleaf:
                    leaf_bool = ((DOY > firstdayleaf) | (DOY < lastdayleaf))
                else:
                    leaf_bool = ((DOY > firstdayleaf) & (DOY < lastdayleaf))
                leafon[0, leaf_bool] = 1

            # % Vegetation transmisivity of shortwave radiation
            psi = leafon * transVeg
            psi[leafon == 0] = 0.5
            # amaxvalue
            vegmax = vegdsm.max()
            amaxvalue = dsm.max() - dsm.min()
            amaxvalue = np.maximum(amaxvalue, vegmax)

            # Elevation vegdsms if buildingDEM includes ground heights
            vegdsm = vegdsm + dsm
            vegdsm[vegdsm == dsm] = 0
            vegdsm2 = vegdsm2 + dsm
            vegdsm2[vegdsm2 == dsm] = 0

            # % Bush separation
            bush = np.logical_not((vegdsm2 * vegdsm)) * vegdsm

            svfbuveg = (svf - (1. - svfveg) * (1. - transVeg))  # % major bug fixed 20141203
        else:
            psi = leafon * 0. + 1.
            svfbuveg = svf
            bush = np.zeros([rows, cols])
            amaxvalue = 0

        # %Initialization of maps
        Knight = np.zeros((rows, cols))
        Tgmap1 = np.zeros((rows, cols))
        Tgmap1E = np.zeros((rows, cols))
        Tgmap1S = np.zeros((rows, cols))
        Tgmap1W = np.zeros((rows, cols))
        Tgmap1N = np.zeros((rows, cols))
        
        # building grid and land cover preparation
        # TO DO: MAYBE NOT HAVE HARD CODED?
        sitein = "landcoverclasses_2016a.txt"
        f = open(sitein)
        lin = f.readlines()
        lc_class = np.zeros((lin.__len__() - 1, 6))
        for i in range(1, lin.__len__()):
            lines = lin[i].split()
            for j in np.arange(1, 7):
                lc_class[i - 1, j - 1] = float(lines[j])
        f.close()
        
        if demforbuild == 0:
            buildings = np.copy(lcgrid)
            buildings[buildings == 7] = 1
            buildings[buildings == 6] = 1
            buildings[buildings == 5] = 1
            buildings[buildings == 4] = 1
            buildings[buildings == 3] = 1
            buildings[buildings == 2] = 0
        else:
            buildings = dsm - dem
            buildings[buildings < 2.] = 1.
            buildings[buildings >= 2.] = 0.

        if saveBuild:
            saveraster(gdal_dsm, outputDir + '/buildings.tif', buildings)

        # Import shadow matrices (Anisotropic sky)
        if folderPathPerez:  #UseAniso
            anisotropic_sky = 1
            data = np.load(folderPathPerez)
            shmat = data['shadowmat']
            vegshmat = data['vegshadowmat']
            vbshvegshmat = data['vbshmat']
            if usevegdem == 1:
                diffsh = np.zeros((rows, cols, shmat.shape[2]))
                for i in range(0, shmat.shape[2]):
                    diffsh[:, :, i] = shmat[:, :, i] - (1 - vegshmat[:, :, i]) * (1 - transVeg) # changes in psi not implemented yet
            else:
                diffsh = shmat
                vegshmat += 1
                vbshvegshmat += 1

            # Estimate number of patches based on shadow matrices
            if shmat.shape[2] == 145:
                patch_option = 1 # patch_option = 1 # 145 patches
            elif shmat.shape[2] == 153:
                patch_option = 2 # patch_option = 2 # 153 patches
            elif shmat.shape[2] == 306:
                patch_option = 3 # patch_option = 3 # 306 patches
            elif shmat.shape[2] == 612:
                patch_option = 4 # patch_option = 4 # 612 patches

            # asvf to calculate sunlit and shaded patches
            asvf = np.arccos(np.sqrt(svf))

            anisotropic_feedback = "Sky divided into " + str(int(shmat.shape[2])) + " patches\n \
                                    Anisotropic sky for diffuse shortwave radiation (Perez et al., 1993) and longwave radiation (Martin & Berdahl, 1984)"
            print(anisotropic_feedback)
        else:
            print("Isotropic sky")
            anisotropic_sky = 0
            diffsh = None
            shmat = None
            vegshmat = None
            vbshvegshmat = None
            asvf = None
            patch_option = 0

        # % Ts parameterisation maps
        if landcover == 1.:
            if np.max(lcgrid) > 21 or np.min(lcgrid) < 1:
                raise Exception("The land cover grid includes integer values higher (or lower) than UMEP-formatted" 
                    "land cover grid (should be integer between 1 and 7). If other LC-classes should be included they also need to be included in landcoverclasses_2016a.txt")
            if np.where(lcgrid) == 3 or np.where(lcgrid) == 4:
                raise Exception("The land cover grid includes values (decidouos and/or conifer) not appropriate for SOLWEIG-formatted land cover grid (should not include 3 or 4).")

            [TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST, TmaxLST_wall] = Tgmaps_v1(lcgrid, lc_class)
        else:
            TgK = Knight + 0.37
            Tstart = Knight - 3.41
            alb_grid = Knight + albedo_g
            emis_grid = Knight + eground
            TgK_wall = 0.37
            Tstart_wall = -3.41
            TmaxLST = 15.
            TmaxLST_wall = 15.

         # Initialisation of time related variables
        if Ta.__len__() == 1:
            timestepdec = 0
        else:
            timestepdec = dectime[1] - dectime[0]
        timeadd = 0.
        timeaddE = 0.
        timeaddS = 0.
        timeaddW = 0.
        timeaddN = 0.
        firstdaytime = 1.

        WriteMetadataSOLWEIG.writeRunInfo(outputDir, filepath_dsm, gdal_dsm, usevegdem,
                                          vegdsm_path, trunkfile, vegdsm2_path, lat, lon, utc, landcover,
                                          lcgrid_path, metfileexist, inputMet, self.metdata,
                                          absK, absL, albedo_b, albedo_g, ewall, eground, onlyglobal, trunkratio,
                                          transVeg, rows, cols, pos, elvis, cyl, demforbuild, anisotropic_sky)

        print("Writing settings for this model run to specified output folder (Filename: RunInfoSOLWEIG_YYYY_DOY_HHMM.txt)")

        # Save svf
        # if anisotropic_sky:
        #     if not poisxy is None:
        #             patch_characteristics = np.zeros((shmat.shape[2], poisxy.shape[0]))
        #             for idx in range(poisxy.shape[0]):
        #                 for idy in range(shmat.shape[2]):
        #                     # Calculations for patches on sky, shmat = 1 = sky is visible
        #                     temp_sky = ((shmat[:,:,idy] == 1) & (vegshmat[:,:,idy] == 1))
        #                     # Calculations for patches that are vegetation, vegshmat = 0 = shade from vegetation
        #                     temp_vegsh = ((vegshmat[:,:,idy] == 0) | (vbshvegshmat[:,:,idy] == 0))
        #                     # Calculations for patches that are buildings, shmat = 0 = shade from buildings
        #                     temp_vbsh = (1 - shmat[:,:,idy]) * vbshvegshmat[:,:,idy]
        #                     temp_sh = (temp_vbsh == 1)
        #                     # Sky patch
        #                     if temp_sky[int(poisxy[idx, 2]), int(poisxy[idx, 1])]:
        #                         patch_characteristics[idy,idx] = 1.8
        #                     # Vegetation patch
        #                     elif (temp_vegsh[int(poisxy[idx, 2]), int(poisxy[idx, 1])]):
        #                         patch_characteristics[idy,idx] = 2.5
        #                     # Building patch
        #                     elif (temp_sh[int(poisxy[idx, 2]), int(poisxy[idx, 1])]):
        #                         patch_characteristics[idy,idx] = 4.5

        #  If metfile starts at night
        CI = 1.

        # Main function
        print("Executing main model")
    
        tmrtplot = np.zeros((rows, cols))
        TgOut1 = np.zeros((rows, cols))

        # Initiate array for I0 values
        if np.unique(DOY).shape[0] > 1:
            unique_days = np.unique(DOY)
            first_unique_day = DOY[DOY == unique_days[0]]
            I0_array = np.zeros((first_unique_day.shape[0]))
        else:
            first_unique_day = DOY.copy()
            I0_array = np.zeros((DOY.shape[0]))

        #numformat = '%d %d %d %d %.5f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
        #            '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f'

        numformat = '%d %d %d %d %.5f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
                    '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
                        '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f'

        for i in np.arange(0, Ta.__len__()):
            print(int(i * (100. / Ta.__len__()))) # move progressbar forward
            # Daily water body temperature
            if landcover == 1:
                if ((dectime[i] - np.floor(dectime[i]))) == 0 or (i == 0):
                    Twater = np.mean(Ta[jday[0] == np.floor(dectime[i])])
            # Nocturnal cloudfraction from Offerle et al. 2003
            if (dectime[i] - np.floor(dectime[i])) == 0:
                daylines = np.where(np.floor(dectime) == dectime[i])
                if daylines.__len__() > 1:
                    alt = altitude[0][daylines]
                    alt2 = np.where(alt > 1)
                    rise = alt2[0][0]
                    [_, CI, _, _, _] = clearnessindex_2013b(zen[0, i + rise + 1], jday[0, i + rise + 1],
                                                            Ta[i + rise + 1],
                                                            RH[i + rise + 1] / 100., radG[i + rise + 1], location,
                                                            P[i + rise + 1])  # i+rise+1 to match matlab code. correct?
                    if (CI > 1.) or (CI == np.inf):
                        CI = 1.
                else:
                    CI = 1.

            # radI[i] = radI[i]/np.sin(altitude[0][i] * np.pi/180)

            Tmrt, Kdown, Kup, Ldown, Lup, Tg, ea, esky, I0, CI, shadow, firstdaytime, timestepdec, timeadd, \
                    Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, Keast, Ksouth, Kwest, Knorth, Least, \
                    Lsouth, Lwest, Lnorth, KsideI, TgOut1, TgOut, radIout, radDout, \
                    Lside, Lsky_patch_characteristics, CI_Tg, CI_TgG, KsideD, \
                        dRad, Kside = so.Solweig_2022a_calc(
                        i, dsm, scale, rows, cols, svf, svfN, svfW, svfE, svfS, svfveg,
                        svfNveg, svfEveg, svfSveg, svfWveg, svfaveg, svfEaveg, svfSaveg, svfWaveg, svfNaveg, \
                        vegdsm, vegdsm2, albedo_b, absK, absL, ewall, Fside, Fup, Fcyl, altitude[0][i],
                        azimuth[0][i], zen[0][i], jday[0][i], usevegdem, onlyglobal, buildings, location,
                        psi[0][i], landcover, lcgrid, dectime[i], altmax[0][i], wallaspect,
                        wallheight, cyl, elvis, Ta[i], RH[i], radG[i], radD[i], radI[i], P[i], amaxvalue,
                        bush, Twater, TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST,
                        TmaxLST_wall, first, second, svfalfa, svfbuveg, firstdaytime, timeadd, timestepdec, 
                        Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, CI, TgOut1, diffsh, shmat, vegshmat, vbshvegshmat, 
                        anisotropic_sky, asvf, patch_option)

            # Save I0 for I0 vs. Kdown output plot to check if UTC is off
            if i < first_unique_day.shape[0]:
                I0_array[i] = I0

            tmrtplot = tmrtplot + Tmrt

            if altitude[0][i] > 0:
                w = 'D'
            else:
                w = 'N'

            # Write to POIs
            # if not poisxy is None:
            #     for k in range(0, poisxy.shape[0]):
            #         poi_save = np.zeros((1, 41))
            #         poi_save[0, 0] = YYYY[0][i]
            #         poi_save[0, 1] = jday[0][i]
            #         poi_save[0, 2] = hours[i]
            #         poi_save[0, 3] = minu[i]
            #         poi_save[0, 4] = dectime[i]
            #         poi_save[0, 5] = altitude[0][i]
            #         poi_save[0, 6] = azimuth[0][i]
            #         poi_save[0, 7] = radIout
            #         poi_save[0, 8] = radDout
            #         poi_save[0, 9] = radG[i]
            #         poi_save[0, 10] = Kdown[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 11] = Kup[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 12] = Keast[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 13] = Ksouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 14] = Kwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 15] = Knorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 16] = Ldown[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 17] = Lup[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 18] = Least[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 19] = Lsouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 20] = Lwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 21] = Lnorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 22] = Ta[i]
            #         poi_save[0, 23] = TgOut[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 24] = RH[i]
            #         poi_save[0, 25] = esky
            #         poi_save[0, 26] = Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 27] = I0
            #         poi_save[0, 28] = CI
            #         poi_save[0, 29] = shadow[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 30] = svf[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 31] = svfbuveg[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 32] = KsideI[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         # Recalculating wind speed based on powerlaw
            #         WsPET = (1.1 / sensorheight) ** 0.2 * Ws[i]
            #         WsUTCI = (10. / sensorheight) ** 0.2 * Ws[i]
            #         resultPET = p._PET(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])], WsPET,
            #                             mbody, age, ht, activity, clo, sex)
            #         poi_save[0, 33] = resultPET
            #         resultUTCI = utci.utci_calculator(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])],
            #                                             WsUTCI)
            #         poi_save[0, 34] = resultUTCI
            #         poi_save[0, 35] = CI_Tg
            #         poi_save[0, 36] = CI_TgG
            #         poi_save[0, 37] = KsideD[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 38] = Lside[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 39] = dRad[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 40] = Kside[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         data_out = outputDir + '/POI_' + str(poiname[k]) + '.txt'
            #         # f_handle = file(data_out, 'a')
            #         f_handle = open(data_out, 'ab')
            #         np.savetxt(f_handle, poi_save, fmt=numformat)
            #         f_handle.close()

            if hours[i] < 10:
                XH = '0'
            else:
                XH = ''
            if minu[i] < 10:
                XM = '0'
            else:
                XM = ''

            if outputTmrt:
                saveraster(gdal_dsm, outputDir + '/Tmrt_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Tmrt)
            if outputKup:
                saveraster(gdal_dsm, outputDir + '/Kup_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Kup)
            if outputKdown:
                saveraster(gdal_dsm, outputDir + '/Kdown_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Kdown)
            if outputLup:
                saveraster(gdal_dsm, outputDir + '/Lup_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Lup)
            if outputLdown:
                saveraster(gdal_dsm, outputDir + '/Ldown_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Ldown)
            if outputSh:
                saveraster(gdal_dsm, outputDir + '/Shadow_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', shadow)
                
            if outputKdiff:
                saveraster(gdal_dsm, outputDir + '/Kdiff_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', dRad)

            # if outputSstr:
            #     saveraster(gdal_dsm, outputDir + '/Sstr_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
            #                     + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Sstr)

            # Sky view image of patches
            # if ((anisotropic_sky == 1) & (i == 0) & (not poisxy is None)):
            #         for k in range(poisxy.shape[0]):
            #             Lsky_patch_characteristics[:,2] = patch_characteristics[:,k]
            #             skyviewimage_out = outputDir + '/POI_' + str(poiname[k]) + '.png'
            #             PolarBarPlot(Lsky_patch_characteristics, altitude[0][i], azimuth[0][i], 'Hemisphere partitioning', skyviewimage_out, 0, 5, 0)

        # Save files for Tree Planter
        if outputTreeplanter:
            print("Saving files for Tree Planter tool")
            # Save DSM
            copyfile(filepath_dsm, outputDir + '/DSM.tif')

            # Save met file
            #copyfile(inputMet, outputDir + '/metfile.txt')

            # Save CDSM
            if usevegdem == 1:
                copyfile(vegdsm_path, outputDir + '/CDSM.tif')

            # Saving settings from SOLWEIG for SOLWEIG1D in TreePlanter
            settingsHeader = 'UTC, posture, onlyglobal, landcover, anisotropic, cylinder, albedo_walls, albedo_ground, emissivity_walls, emissivity_ground, absK, absL, elevation, patch_option'
            settingsFmt = '%i', '%i', '%i', '%i', '%i', '%i', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%i'
            settingsData = np.array([[utc, pos, onlyglobal, landcover, anisotropic_sky, cyl, albedo_b, albedo_g, ewall, eground, absK, absL, alt, patch_option]])
            np.savetxt(outputDir + '/treeplantersettings.txt', settingsData, fmt=settingsFmt, header=settingsHeader, delimiter=' ')

        # Output I0 vs. Kglobal plot
        radG_for_plot = radG[DOY == first_unique_day[0]]
        hours_for_plot = hours[DOY == first_unique_day[0]]
        fig, ax = plt.subplots()
        ax.plot(hours_for_plot, I0_array, label='I0')
        ax.plot(hours_for_plot, radG_for_plot, label='Kglobal')
        ax.set_ylabel('Shortwave radiation [$Wm^{-2}$]')
        ax.set_xlabel('Hours')
        ax.set_title('UTC' + str(int(utc)))
        ax.legend()
        fig.savefig(outputDir + '/metCheck.png', dpi=150)

        # Copying met file for SpatialTC
        copyfile(inputMet, outputDir + '/metforcing.txt')
        
        tmrtplot = tmrtplot / Ta.__len__()  # fix average Tmrt instead of sum, 20191022
        saveraster(gdal_dsm, outputDir + '/Tmrt_average.tif', tmrtplot)
        print("SOLWEIG: Model calculation finished.")

        rmtree(self.temp_dir, ignore_errors=True)  
     
        return {self.OUTPUT_DIR: outputDir}

INPUT_DSM = "D:/Geomatics/thesis/heattryout/preprocess/DSM_smaller.tif"
INPUT_SVF = "D:/Geomatics/thesis/heattryout/preprocess/skyview/svfs.zip"
INPUT_LC = "D:/Geomatics/thesis/heattryout/preprocess/landuse.tif"
INPUT_CDSM = "D:/Geomatics/thesis/heattryout/preprocess/CHM_smaller.tif"
INPUT_HEIGHT = "D:/Geomatics/thesis/heattryout/preprocess/wallheight.tif"
INPUT_ASPECT = "D:/Geomatics/thesis/heattryout/preprocess/wallaspect.tif"
UTC = 1
OUTPUT_DIR = "D:/Geomatics/thesis/codetest"
INPUT_MET = "D:/Geomatics/thesis/heattryout/preprocess/climatedata/UMEPclimate_oneday.txt"


test = SOLWEIGAlgorithm(INPUT_DSM, INPUT_SVF, INPUT_CDSM, INPUT_HEIGHT, INPUT_ASPECT, UTC, OUTPUT_DIR, INPUT_MET, INPUT_LC=INPUT_LC)
test.processAlgorithm()